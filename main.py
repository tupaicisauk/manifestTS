import os
import json
import discord
from discord.ext import tasks
from discord import app_commands
from flask import Flask
from threading import Thread
from google.oauth2 import service_account
from googleapiclient.discovery import build
import aiohttp
import requests

# ====== KEEP ALIVE SERVER ======
app = Flask(__name__)

@app.route('/')
def home():
    return "Bot is alive!"

def run():
    app.run(host="0.0.0.0", port=8080)

def keep_alive():
    t = Thread(target=run)
    t.start()

# ====== DISCORD BOT ======
intents = discord.Intents.default()
bot = discord.Client(intents=intents)
tree = app_commands.CommandTree(bot)

DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
DISCORD_CHANNEL_ID = int(os.getenv("DISCORD_CHANNEL_ID"))
FOLDER_ID = os.getenv("FOLDER_ID")

# ====== GOOGLE DRIVE SETUP ======
SCOPES = ["https://www.googleapis.com/auth/drive"]
SERVICE_ACCOUNT_INFO = os.getenv("GDRIVE_CREDENTIALS")

if not SERVICE_ACCOUNT_INFO:
    raise ValueError("‚ùå GDRIVE_CREDENTIALS tidak ditemukan di environment variable!")

creds = service_account.Credentials.from_service_account_info(
    json.loads(SERVICE_ACCOUNT_INFO), scopes=SCOPES
)
drive_service = build("drive", "v3", credentials=creds)

# ====== CACHE UNTUK CEK FILE BARU ======
known_files = {}  # simpan {filename: fileId}
ENABLE_UPLOAD_WATCH = False  # default mati

# ====== INIT FILE EXISTING ======
def initialize_known_files():
    global known_files
    try:
        results = drive_service.files().list(
            q=f"'{FOLDER_ID}' in parents",
            fields="files(id, name, modifiedTime)"
        ).execute()
        items = results.get("files", [])
        known_files = {f["name"]: f["id"] for f in items}
        print(f"üîπ Initialized cache dengan {len(known_files)} file (tidak akan notif ulang).")
    except Exception as e:
        print(f"‚ùå Error init known files: {e}")

# ====== FETCH DATA DARI STEAM ======
async def fetch_steam_info(appid: str):
    try:
        async with aiohttp.ClientSession() as session:
            store_url = f"https://store.steampowered.com/api/appdetails?appids={appid}"
            async with session.get(store_url) as resp:
                data = await resp.json()
                if data[str(appid)]["success"]:
                    game_name = data[str(appid)]["data"]["name"]
                    header_img = data[str(appid)]["data"]["header_image"]
                else:
                    game_name, header_img = f"AppID {appid}", None
        return {
            "name": game_name,
            "steam": f"https://store.steampowered.com/app/{appid}",
            "steamdb": f"https://steamdb.info/app/{appid}",
            "header": header_img
        }
    except:
        return {
            "name": f"AppID {appid}",
            "steam": f"https://store.steampowered.com/app/{appid}",
            "steamdb": f"https://steamdb.info/app/{appid}",
            "header": None
        }

# ====== SLASH COMMAND /gen ======
@tree.command(name="gen", description="Generate manifest dari Google Drive dengan AppID")
async def gen(interaction: discord.Interaction, appid: str):
    await interaction.response.defer()

    try:
        query = f"name contains '{appid}.zip' and '{FOLDER_ID}' in parents"
        results = drive_service.files().list(
            q=query,
            fields="files(id, name, createdTime, modifiedTime, size, mimeType)"
        ).execute()
        items = results.get("files", [])

        if not items:
            await interaction.followup.send(
                f"‚ùå File untuk AppID {appid} tidak ditemukan di Google Drive."
            )
            return

        file = items[0]
        file_id, file_name = file["id"], file["name"]
        created, modified = file["createdTime"], file["modifiedTime"]

        info = await fetch_steam_info(appid)

        embed = discord.Embed(
            title=f"‚úÖ Manifest Generated: {info['name']}",
            description=f"Successfully generated manifest files for **{info['name']}** ({appid})",
            color=discord.Color.green()
        )
        embed.add_field(name="Links", value=f"[Steam Store]({info['steam']}) | [SteamDB]({info['steamdb']})", inline=False)
        embed.add_field(name="Google Drive", value=f"Upload date: {created[:10]} ‚Ä¢ Updated date: {modified[:10]}", inline=False)
        if info['header']:
            embed.set_image(url=info['header'])
        embed.set_footer(text="Generated by TechStation Manifest")

        await interaction.followup.send(embed=embed)

    except Exception as e:
        await interaction.followup.send(
            f"‚ùå Error saat generate manifest: {str(e)}"
        )

# ====== BACKGROUND TASK CEK FILE BARU ======
@tasks.loop(minutes=1)
async def check_new_files():
    global known_files, ENABLE_UPLOAD_WATCH
    if not ENABLE_UPLOAD_WATCH:
        return

    try:
        results = drive_service.files().list(
            q=f"'{FOLDER_ID}' in parents",
            fields="files(id, name, createdTime, modifiedTime)"
        ).execute()
        items = results.get("files", [])

        channel = bot.get_channel(DISCORD_CHANNEL_ID)

        for f in items:
            fname, fid = f["name"], f["id"]

            # CASE 1: file baru
            if fname not in known_files:
                known_files[fname] = fid
                appid = fname.replace(".zip", "")
                info = await fetch_steam_info(appid)

                embed = discord.Embed(
                    title=f"üÜï New Game Added: {info['name']}",
                    description=f"File baru diupload: **{info['name']}** ({appid})",
                    color=discord.Color.blue()
                )
                embed.add_field(name="Links", value=f"[Steam Store]({info['steam']}) | [SteamDB]({info['steamdb']})", inline=False)
                embed.add_field(name="Upload Info", value=f"Upload date: {f['createdTime'][:10]} ‚Ä¢ Updated date: {f['modifiedTime'][:10]}", inline=False)
                if info['header']:
                    embed.set_image(url=info['header'])
                embed.set_footer(text="Reported by TechStation Manifest")

                await channel.send(embed=embed)

            # CASE 2: file lama tapi diganti (ID beda ‚Üí replace)
            elif known_files[fname] != fid:
                known_files[fname] = fid
                appid = fname.replace(".zip", "")
                info = await fetch_steam_info(appid)

                embed = discord.Embed(
                    title=f"‚ôªÔ∏è Game Updated: {info['name']}",
                    description=f"File lama diperbarui: **{info['name']}** ({appid})",
                    color=discord.Color.orange()
                )
                embed.add_field(name="Links", value=f"[Steam Store]({info['steam']}) | [SteamDB]({info['steamdb']})", inline=False)
                embed.add_field(name="Upload Info", value=f"Updated date: {f['modifiedTime'][:10]}", inline=False)
                if info['header']:
                    embed.set_image(url=info['header'])
                embed.set_footer(text="Reported by TechStation Manifest")

                await channel.send(embed=embed)

    except Exception as e:
        print(f"‚ùå Error di check_new_files: {e}")

# ====== SLASH COMMAND UNTUK NOTIF ======
@tree.command(name="notif", description="Aktifkan atau matikan auto-notif upload")
async def notif(interaction: discord.Interaction, mode: str):
    global ENABLE_UPLOAD_WATCH
    mode = mode.lower()

    if mode == "on":
        ENABLE_UPLOAD_WATCH = True
        initialize_known_files()
        await interaction.response.send_message("üîî Notifikasi upload AKTIF. Hanya file baru/update yang akan dikirim.")
    elif mode == "off":
        ENABLE_UPLOAD_WATCH = False
        await interaction.response.send_message("üîï Notifikasi upload DIMATIKAN.")
    else:
        await interaction.response.send_message("‚ùå Gunakan: `/notif on` atau `/notif off`")

# ====== ON READY ======
@bot.event
async def on_ready():
    await tree.sync()
    print(f"‚úÖ Bot {bot.user} sudah online dengan slash command!")
    initialize_known_files()
    check_new_files.start()

# ====== START BOT ======
keep_alive()
bot.run(DISCORD_TOKEN)
