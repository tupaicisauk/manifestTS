import os
import json
import discord
from discord.ext import tasks
from discord import app_commands
from flask import Flask
from threading import Thread
from google.oauth2 import service_account
from googleapiclient.discovery import build
import aiohttp

# ====== KEEP ALIVE SERVER ======
app = Flask(__name__)

@app.route('/')
def home():
    return "Bot is alive!"

def run():
    app.run(host="0.0.0.0", port=8080)

def keep_alive():
    t = Thread(target=run)
    t.start()

# ====== DISCORD BOT ======
intents = discord.Intents.default()
bot = discord.Client(intents=intents)
tree = app_commands.CommandTree(bot)

DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
DISCORD_CHANNEL_ID = int(os.getenv("DISCORD_CHANNEL_ID"))
FOLDER_ID = os.getenv("FOLDER_ID")

# ====== GOOGLE DRIVE SETUP ======
SCOPES = ["https://www.googleapis.com/auth/drive"]
SERVICE_ACCOUNT_INFO = os.getenv("GDRIVE_CREDENTIALS")

if not SERVICE_ACCOUNT_INFO:
    raise ValueError("‚ùå GDRIVE_CREDENTIALS tidak ditemukan di environment variable!")

creds = service_account.Credentials.from_service_account_info(
    json.loads(SERVICE_ACCOUNT_INFO), scopes=SCOPES
)
drive_service = build("drive", "v3", credentials=creds)

# ====== CACHE ======
known_files = {}  # { filename: {"id": id, "mtime": modifiedTime} }
ENABLE_UPLOAD_WATCH = False

# ====== INIT CACHE ======
def initialize_known_files():
    global known_files
    try:
        results = drive_service.files().list(
            q=f"'{FOLDER_ID}' in parents and trashed=false",
            fields="files(id, name, modifiedTime)"
        ).execute()
        items = results.get("files", [])
        known_files = {f["name"]: {"id": f["id"], "mtime": f["modifiedTime"]} for f in items}
        print(f"üîπ Initialized {len(known_files)} file ke cache (tidak notif ulang).")
    except Exception as e:
        print(f"‚ùå Error init known files: {e}")

# ====== FETCH DATA DARI STEAM ======
async def fetch_steam_info(appid: str):
    try:
        async with aiohttp.ClientSession() as session:
            store_url = f"https://store.steampowered.com/api/appdetails?appids={appid}"
            async with session.get(store_url) as resp:
                data = await resp.json()
                if data[str(appid)]["success"]:
                    game_name = data[str(appid)]["data"]["name"]
                    header_img = data[str(appid)]["data"]["header_image"]
                else:
                    game_name, header_img = f"AppID {appid}", None
        return {
            "name": game_name,
            "steam": f"https://store.steampowered.com/app/{appid}",
            "steamdb": f"https://steamdb.info/app/{appid}",
            "header": header_img
        }
    except:
        return {
            "name": f"AppID {appid}",
            "steam": f"https://store.steampowered.com/app/{appid}",
            "steamdb": f"https://steamdb.info/app/{appid}",
            "header": None
        }

# ====== SLASH COMMAND /gen ======
@tree.command(name="gen", description="Generate manifest dari Google Drive dengan AppID")
async def gen(interaction: discord.Interaction, appid: str):
    await interaction.response.defer()

    try:
        query = f"name contains '{appid}.zip' and '{FOLDER_ID}' in parents and trashed=false"
        results = drive_service.files().list(
            q=query,
            fields="files(id, name, createdTime, modifiedTime)"
        ).execute()
        items = results.get("files", [])

        if not items:
            await interaction.followup.send(f"‚ùå File untuk AppID {appid} tidak ditemukan.")
            return

        file = items[0]
        file_id, file_name = file["id"], file["name"]
        created, modified = file["createdTime"], file["modifiedTime"]

        info = await fetch_steam_info(appid)

        embed = discord.Embed(
            title=f"‚úÖ Manifest Generated: {info['name']}",
            description=f"File: **{file_name}**\nAppID: {appid}",
            color=discord.Color.green()
        )
        embed.add_field(name="Links", value=f"[Steam Store]({info['steam']}) | [SteamDB]({info['steamdb']})", inline=False)
        embed.add_field(name="Google Drive", value=f"Upload: {created[:10]} ‚Ä¢ Update: {modified[:10]}", inline=False)
        if info['header']:
            embed.set_image(url=info['header'])
        embed.set_footer(text="Generated by TechStation Manifest")

        await interaction.followup.send(embed=embed)

    except Exception as e:
        await interaction.followup.send(f"‚ùå Error saat generate manifest: {str(e)}")

# ====== BACKGROUND TASK CEK FILE ======
@tasks.loop(minutes=1)
async def check_new_files():
    global known_files, ENABLE_UPLOAD_WATCH
    if not ENABLE_UPLOAD_WATCH:
        return

    try:
        results = drive_service.files().list(
            q=f"'{FOLDER_ID}' in parents and trashed=false",
            fields="files(id, name, createdTime, modifiedTime)"
        ).execute()
        items = results.get("files", [])
        channel = bot.get_channel(DISCORD_CHANNEL_ID)

        for f in items:
            fname, fid, mtime = f["name"], f["id"], f["modifiedTime"]

            # ambil AppID dengan lebih aman
            appid = os.path.splitext(fname)[0]

            if fname in known_files:
                # CASE 1: ID beda -> updated
                if known_files[fname]["id"] != fid:
                    known_files[fname] = {"id": fid, "mtime": mtime}
                    info = await fetch_steam_info(appid)
                    embed = discord.Embed(
                        title=f"‚ôªÔ∏è Game Updated: {info['name']}",
                        description=f"File lama diganti baru: **{fname}**",
                        color=discord.Color.orange()
                    )
                    embed.add_field(name="Upload Info", value=f"Updated: {mtime[:10]}", inline=False)
                    await channel.send(embed=embed)

                # CASE 2: ID sama tapi modifiedTime berubah -> updated
                elif known_files[fname]["mtime"] != mtime:
                    known_files[fname]["mtime"] = mtime
                    info = await fetch_steam_info(appid)
                    embed = discord.Embed(
                        title=f"‚ôªÔ∏è Game Updated (Replaced Content): {info['name']}",
                        description=f"Isi file diperbarui: **{fname}**",
                        color=discord.Color.orange()
                    )
                    embed.add_field(name="Upload Info", value=f"Updated: {mtime[:10]}", inline=False)
                    await channel.send(embed=embed)

            else:
                # CASE 3: file baru
                known_files[fname] = {"id": fid, "mtime": mtime}
                info = await fetch_steam_info(appid)
                embed = discord.Embed(
                    title=f"üÜï New Game Added: {info['name']}",
                    description=f"File baru: **{fname}**",
                    color=discord.Color.blue()
                )
                embed.add_field(name="Upload Info", value=f"Upload: {f['createdTime'][:10]} ‚Ä¢ Update: {mtime[:10]}", inline=False)
                await channel.send(embed=embed)

    except Exception as e:
        ENABLE_UPLOAD_WATCH = False
        print(f"‚ùå Error di check_new_files, notif otomatis dimatikan: {e}")

# ====== SLASH COMMAND NOTIF ======
@tree.command(name="notif", description="Aktifkan atau matikan auto-notif upload/update")
async def notif(interaction: discord.Interaction, mode: str):
    global ENABLE_UPLOAD_WATCH
    mode = mode.lower()

    if mode == "on":
        ENABLE_UPLOAD_WATCH = True
        initialize_known_files()
        await interaction.response.send_message("üîî Notifikasi AKTIF (hanya file baru/update).")
    elif mode == "off":
        ENABLE_UPLOAD_WATCH = False
        await interaction.response.send_message("üîï Notifikasi DIMATIKAN.")
    else:
        await interaction.response.send_message("‚ùå Gunakan `/notif on` atau `/notif off`")

# ====== ON READY ======
@bot.event
async def on_ready():
    await tree.sync()
    print(f"‚úÖ Bot {bot.user} sudah online!")
    initialize_known_files()
    check_new_files.start()

# ====== START BOT ======
keep_alive()
bot.run(DISCORD_TOKEN)
